<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="LDouble" rel="Chapter" href="LDouble.html">
<link title="ComplexL" rel="Chapter" href="ComplexL.html">
<link title="Ctypes" rel="Chapter" href="Ctypes.html">
<link title="PosixTypes" rel="Chapter" href="PosixTypes.html">
<link title="Ctypes_types" rel="Chapter" href="Ctypes_types.html">
<link title="Ctypes_printers" rel="Chapter" href="Ctypes_printers.html">
<link title="Dl" rel="Chapter" href="Dl.html">
<link title="Libffi_abi" rel="Chapter" href="Libffi_abi.html">
<link title="Foreign" rel="Chapter" href="Foreign.html">
<link title="Cstubs_structs" rel="Chapter" href="Cstubs_structs.html">
<link title="Cstubs" rel="Chapter" href="Cstubs.html">
<link title="Cstubs_inverted" rel="Chapter" href="Cstubs_inverted.html"><title>Index of values</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Index of values</h1>
<table>
<tr><td align="left"><br></td></tr>
<tr><td><a href="Ctypes.html#VAL(!@)">(!@)</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">!@ p</code> dereferences the pointer <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VAL(+@)">(+@)</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
If <code class="code">p</code> is a pointer to an array element then <code class="code">p +@ n</code> computes the
    address of the <code class="code">n</code>th next element.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VAL(-@)">(-@)</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
If <code class="code">p</code> is a pointer to an array element then <code class="code">p -@ n</code> computes the address
    of the nth previous element.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VAL(<-@)">(&lt;-@)</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">p &lt;-@ v</code> writes the value <code class="code">v</code> to the address <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VAL(@->)">(@-&gt;)</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Construct a function type from a type and an existing function type.
</div>
</td></tr>
<tr><td><a href="Ctypes.FOREIGN.html#VAL(@->)">(@-&gt;)</a> [<a href="Ctypes.FOREIGN.html">Ctypes.FOREIGN</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.html#VAL(@.)">(@.)</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">s @. f</code> computes the address of the field <code class="code">f</code> in the structure or union
    value <code class="code">s</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VAL(|->)">(|-&gt;)</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">p |-&gt; f</code> computes the address of the field <code class="code">f</code> in the structure or union
    value pointed to by <code class="code">p</code>.
</div>
</td></tr>
<tr><td align="left"><br>A</td></tr>
<tr><td><a href="Libffi_abi.html#VALabi_code">abi_code</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="LDouble.html#VALabs">abs</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
<code class="code">abs f</code> returns absolute value of <code class="code">f</code>
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALabstract">abstract</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Create an abstract type specification from the size and alignment
      requirements for the type.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALacos">acos</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Arc cosine
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALacosh">acosh</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Inverse hyperbolic cosine
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALadd">add</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Addition
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALadd">add</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Addition
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALaddr">addr</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">addr s</code> returns the address of the structure or union <code class="code">s</code>.
</div>
</td></tr>
<tr><td><a href="Libffi_abi.html#VALaix">aix</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.html#VALalignment">alignment</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">alignment t</code> computes the alignment requirements of the type <code class="code">t</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALallocate">allocate</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">allocate t v</code> allocates a fresh value of type <code class="code">t</code>, initialises it
    with <code class="code">v</code> and returns its address.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALallocate_n">allocate_n</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">allocate_n t ~count:n</code> allocates a fresh array with element type
    <code class="code">t</code> and length <code class="code">n</code>, and returns its address.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALarg">arg</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Argument.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALarray">array</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Construct a sized array type from a length and an existing type (called
      the <i>element type</i>).
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALarray1">array1</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
The class of <code class="code">Bigarray.Array1.t</code> values
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALarray2">array2</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
The class of <code class="code">Bigarray.Array2.t</code> values
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALarray3">array3</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
The class of <code class="code">Bigarray.Array3.t</code> values
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALarray_of_bigarray">array_of_bigarray</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">array_of_bigarray c b</code> converts the bigarray value <code class="code">b</code> to a value of type
    <a href="Ctypes.CArray.html#TYPEt"><code class="code">Ctypes.CArray.t</code></a>.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALasin">asin</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Arc sine
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALasinh">asinh</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Inverse hyperbolic sine
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALatan">atan</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Arc tangent
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALatan2">atan2</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
<code class="code">atan2 y x</code> returns the arc tangent of <code class="code">y /. x</code>.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALatanh">atanh</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Inverse hyperbolic tangent
</div>
</td></tr>
<tr><td align="left"><br>B</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALbigarray">bigarray</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Construct a sized C-layout bigarray type representation from a bigarray
      class, the dimensions, and the <code class="code">Bigarray.kind</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALbigarray_of_array">bigarray_of_array</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">bigarray_of_array c k a</code> converts the <a href="Ctypes.CArray.html#TYPEt"><code class="code">Ctypes.CArray.t</code></a> value <code class="code">a</code> to a
    C-layout bigarray value.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALbigarray_of_ptr">bigarray_of_ptr</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">bigarray_of_ptr c dims k p</code> converts the C pointer <code class="code">p</code> to a C-layout
    bigarray value.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALbigarray_start">bigarray_start</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Return the address of the first element of the given Bigarray value.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALbool">bool</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">bool</code>.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALbyte_sizes">byte_sizes</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
size, in bytes, used for storing long doubles, 
    and the actual number of bytes used by the value.
</div>
</td></tr>
<tr><td align="left"><br>C</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALcamlint">camlint</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing an integer type with the same storage requirements as
      an OCaml <code class="code">int</code>.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALceil">ceil</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Round above to an integer value.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALchar">char</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">char</code>.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALclassify">classify</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Return the class of the given floating-point number:
   normal, subnormal, zero, infinite, or not a number.
</div>
</td></tr>
<tr><td><a href="PosixTypes.html#VALclock_t">clock_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.html#VALcoerce">coerce</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">coerce t1 t2</code> returns a coercion function between the types represented
    by <code class="code">t1</code> and <code class="code">t2</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALcoerce_fn">coerce_fn</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">coerce_fn f1 f2</code> returns a coercion function between the function
    types represented by <code class="code">f1</code> and <code class="code">f2</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALcomplex32">complex32</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C99 single-precision <code class="code">float complex</code> type.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALcomplex64">complex64</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C99 double-precision <code class="code">double complex</code> type.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALcomplexld">complexld</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C99 long-double-precision <code class="code">long double complex</code> type.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALconj">conj</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Conjugate: given the complex <code class="code">x + i.y</code>, returns <code class="code">x - i.y</code>.
</div>
</td></tr>
<tr><td><a href="Cstubs.Types.TYPE.html#VALconstant">constant</a> [<a href="Cstubs.Types.TYPE.html">Cstubs.Types.TYPE</a>]</td>
<td><div class="info">
<code class="code">constant name typ</code> retrieves the value of the compile-time constant
        <code class="code">name</code> of type <code class="code">typ</code>.
</div>
</td></tr>
<tr><td><a href="Cstubs_structs.TYPE.html#VALconstant">constant</a> [<a href="Cstubs_structs.TYPE.html">Cstubs_structs.TYPE</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.CArray.html#VALcopy">copy</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">copy a</code> creates a fresh array with the same elements as <code class="code">a</code>.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALcopysign">copysign</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
<code class="code">copysign x y</code> returns a float whose absolute value is that of <code class="code">x</code>
  and whose sign is that of <code class="code">y</code>.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALcos">cos</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Cosine.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALcosh">cosh</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Hyperbolic cosine
</div>
</td></tr>
<tr><td><a href="Ctypes.Root.html#VALcreate">create</a> [<a href="Ctypes.Root.html">Ctypes.Root</a>]</td>
<td><div class="info">
<code class="code">create v</code> allocates storage for the address of the OCaml value <code class="code">v</code>,
      registers the storage as a root, and returns its address.
</div>
</td></tr>
<tr><td align="left"><br>D</td></tr>
<tr><td><a href="Libffi_abi.html#VALdarwin">darwin</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Libffi_abi.html#VALdefault_abi">default_abi</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="PosixTypes.html#VALdev_t">dev_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="ComplexL.html#VALdiv">div</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Division
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALdiv">div</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Division
</div>
</td></tr>
<tr><td><a href="Dl.html#VALdlclose">dlclose</a> [<a href="Dl.html">Dl</a>]</td>
<td><div class="info">
Close a dynamic library.
</div>
</td></tr>
<tr><td><a href="Dl.html#VALdlopen">dlopen</a> [<a href="Dl.html">Dl</a>]</td>
<td><div class="info">
Open a dynamic library.
</div>
</td></tr>
<tr><td><a href="Dl.html#VALdlsym">dlsym</a> [<a href="Dl.html">Dl</a>]</td>
<td><div class="info">
Look up a symbol in a dynamic library.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALdouble">double</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">double</code>.
</div>
</td></tr>
<tr><td align="left"><br>E</td></tr>
<tr><td><a href="Libffi_abi.html#VALeabi">eabi</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.CArray.html#VALelement_type">element_type</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
Retrieve the element type of an array.
</div>
</td></tr>
<tr><td><a href="Cstubs_inverted.INTERNAL.html#VALenum">enum</a> [<a href="Cstubs_inverted.INTERNAL.html">Cstubs_inverted.INTERNAL</a>]</td>
<td></td></tr>
<tr><td><a href="Cstubs.Types.TYPE.html#VALenum">enum</a> [<a href="Cstubs.Types.TYPE.html">Cstubs.Types.TYPE</a>]</td>
<td><div class="info">
<code class="code">enum name ?unexpected alist</code> builds a type representation for the
        enum named <code class="code">name</code>.
</div>
</td></tr>
<tr><td><a href="Cstubs_structs.TYPE.html#VALenum">enum</a> [<a href="Cstubs_structs.TYPE.html">Cstubs_structs.TYPE</a>]</td>
<td></td></tr>
<tr><td><a href="LDouble.html#VALepsilon">epsilon</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
The difference between <code class="code">1.0</code> and the smallest exactly representable
    floating-point number greater than <code class="code">1.0</code>.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALexp">exp</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Exponentiation.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALexp">exp</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Exponential
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALexpm1">expm1</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
<code class="code">expm1 x</code> computes <code class="code">exp x -. 1.0</code>, giving numerically-accurate results
    even if <code class="code">x</code> is close to <code class="code">0.0</code>.
</div>
</td></tr>
<tr><td align="left"><br>F</td></tr>
<tr><td><a href="Libffi_abi.html#VALfastcall">fastcall</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALfield">field</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
<code class="code">field ty label ty'</code> adds a field of type <code class="code">ty'</code> with label <code class="code">label</code> to the
      structure or union type <code class="code">ty</code> and returns a field value that can be used to
      read and write the field in structure or union instances (e.g.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALfield_name">field_name</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">field_name f</code> returns the name of the field <code class="code">f</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALfield_type">field_type</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">field_type f</code> returns the type of the field <code class="code">f</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALfloat">float</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C single-precision <code class="code">float</code> type.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALfloor">floor</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Round below to an integer value.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALfold_left">fold_left</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">CArray.fold_left (@) x a</code> computes 
         <code class="code">(((x @ a.(0)) @ a.(1)) ...) @ a.(n-1)</code>
       where <code class="code">n</code> is the length of the array <code class="code">a</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALfold_right">fold_right</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">CArray.fold_right f a x</code> computes
         <code class="code">a.(0) @ (a.(1) @ ( ... (a.(n-1) @ x) ...))</code>
       where <code class="code">n</code> is the length of the array <code class="code">a</code>.
</div>
</td></tr>
<tr><td><a href="Foreign.html#VALforeign">foreign</a> [<a href="Foreign.html">Foreign</a>]</td>
<td><div class="info">
<code class="code">foreign name typ</code> exposes the C function of type <code class="code">typ</code> named by <code class="code">name</code> as
    an OCaml value.
</div>
</td></tr>
<tr><td><a href="Ctypes.FOREIGN.html#VALforeign">foreign</a> [<a href="Ctypes.FOREIGN.html">Ctypes.FOREIGN</a>]</td>
<td></td></tr>
<tr><td><a href="Foreign.html#VALforeign_value">foreign_value</a> [<a href="Foreign.html">Foreign</a>]</td>
<td><div class="info">
<code class="code">foreign_value name typ</code> exposes the C value of type <code class="code">typ</code> named by <code class="code">name</code>
    as an OCaml value.
</div>
</td></tr>
<tr><td><a href="Ctypes.FOREIGN.html#VALforeign_value">foreign_value</a> [<a href="Ctypes.FOREIGN.html">Ctypes.FOREIGN</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.html#VALformat">format</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Pretty-print a representation of the C value to the specified formatter.
</div>
</td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_array">format_array</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_clock_t">format_clock_t</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_complexld">format_complexld</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_dev_t">format_dev_t</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_fn">format_fn</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.html#VALformat_fn">format_fn</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Pretty-print a C representation of the function type to the specified
    formatter.
</div>
</td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_ino_t">format_ino_t</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_ldouble">format_ldouble</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_llong">format_llong</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_long">format_long</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_mode_t">format_mode_t</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_nlink_t">format_nlink_t</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_ocaml">format_ocaml</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_off_t">format_off_t</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_pid_t">format_pid_t</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_pointer">format_pointer</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_sint">format_sint</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_size_t">format_size_t</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_ssize_t">format_ssize_t</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_struct">format_struct</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_time_t">format_time_t</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_typ">format_typ</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.html#VALformat_typ">format_typ</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Pretty-print a C representation of the type to the specified formatter.
</div>
</td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_uchar">format_uchar</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_uint">format_uint</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_uint16">format_uint16</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_uint32">format_uint32</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_uint64">format_uint64</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_uint8">format_uint8</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_ullong">format_ullong</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_ulong">format_ulong</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_union">format_union</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_useconds_t">format_useconds_t</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_printers.html#VALformat_ushort">format_ushort</a> [<a href="Ctypes_printers.html">Ctypes_printers</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALfortran_bigarray">fortran_bigarray</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Construct a sized Fortran-layout bigarray type representation from a
      bigarray class, the dimensions, and the <code class="code">Bigarray.kind</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALfortran_bigarray_of_ptr">fortran_bigarray_of_ptr</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">fortran_bigarray_of_ptr c dims k p</code> converts the C pointer <code class="code">p</code> to a
    Fortran-layout bigarray value.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALfrexp">frexp</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
<code class="code">frexp f</code> returns the pair of the significant and the exponent of <code class="code">f</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALfrom_ptr">from_ptr</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">from_ptr p n</code> creates an <code class="code">n</code>-length array reference to the memory at
      address <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALfrom_voidp">from_voidp</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Conversion from <code class="code">void *</code>.
</div>
</td></tr>
<tr><td><a href="Foreign.html#VALfunptr">funptr</a> [<a href="Foreign.html">Foreign</a>]</td>
<td><div class="info">
Construct a function pointer type from a function type.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALfunptr_of_raw_address">funptr_of_raw_address</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Convert the numeric representation of an address to a function pointer
</div>
</td></tr>
<tr><td><a href="Foreign.html#VALfunptr_opt">funptr_opt</a> [<a href="Foreign.html">Foreign</a>]</td>
<td><div class="info">
Construct a function pointer type from a function type.
</div>
</td></tr>
<tr><td align="left"><br>G</td></tr>
<tr><td><a href="Libffi_abi.html#VALgcc_sysv">gcc_sysv</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.html#VALgenarray">genarray</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
The class of <code class="code">Bigarray.Genarray.t</code> values
</div>
</td></tr>
<tr><td><a href="Ctypes.Root.html#VALget">get</a> [<a href="Ctypes.Root.html">Ctypes.Root</a>]</td>
<td><div class="info">
<code class="code">get p</code> retrieves the OCaml value whose address is stored at <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALget">get</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">get a n</code> returns the <code class="code">n</code>th element of the zero-indexed array <code class="code">a</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALgetf">getf</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">getf s f</code> retrieves the value of the field <code class="code">f</code> in the structure or union
    <code class="code">s</code>.
</div>
</td></tr>
<tr><td align="left"><br>H</td></tr>
<tr><td><a href="LDouble.html#VALhypot">hypot</a> [<a href="LDouble.html">LDouble</a>]</td>
<td></td></tr>
<tr><td align="left"><br>I</td></tr>
<tr><td><a href="ComplexL.html#VALi">i</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
<code class="code">0 + i</code>
</div>
</td></tr>
<tr><td><a href="Cstubs.html#VALignore_errno">ignore_errno</a> [<a href="Cstubs.html">Cstubs</a>]</td>
<td><div class="info">
Generate code with no special support for errno.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALim">im</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
return the imaginary part of the long double complex
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALinfinity">infinity</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Positive infinity
</div>
</td></tr>
<tr><td><a href="PosixTypes.html#VALino_t">ino_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALint">int</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type (<code class="code">signed</code>) <code class="code">int</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALint16_t">int16_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing a 16-bit signed integer C type.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALint32_t">int32_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing a 32-bit signed integer C type.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALint64_t">int64_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing a 64-bit signed integer C type.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALint8_t">int8_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing an 8-bit signed integer C type.
</div>
</td></tr>
<tr><td><a href="Cstubs_inverted.INTERNAL.html#VALinternal">internal</a> [<a href="Cstubs_inverted.INTERNAL.html">Cstubs_inverted.INTERNAL</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALintptr_t">intptr_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">intptr_t</code>.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALinv">inv</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Multiplicative inverse (<code class="code">1/z</code>).
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALis_null">is_null</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">is_null p</code> is true when <code class="code">p</code> is a null pointer.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALiter">iter</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">iter f a</code> is analogous to <code class="code">Array.iter f a</code>: it applies <code class="code">f</code> in turn to
      all the elements of <code class="code">a</code>.
</div>
</td></tr>
<tr><td align="left"><br>L</td></tr>
<tr><td><a href="LDouble.html#VALldexp">ldexp</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
<code class="code">ldexp x n</code> returns <code class="code">x *. 2 ** n</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALldouble">ldouble</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">long double</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALlength">length</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
Return the number of elements of the given array.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALlift_typ">lift_typ</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
<code class="code">lift_typ t</code> turns a concrete type representation into an abstract type
      representation.
</div>
</td></tr>
<tr><td><a href="Libffi_abi.html#VALlinux">linux</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Libffi_abi.html#VALlinux64">linux64</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Libffi_abi.html#VALlinux_soft_float">linux_soft_float</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALllong">llong</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type (<code class="code">signed</code>) <code class="code">long long</code>.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALlog">log</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Natural logarithm (in base <code class="code">e</code>).
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALlog">log</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Natural logarithm
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALlog10">log10</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Base 10 logarithm
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALlog1p">log1p</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
<code class="code">log1p x</code> computes <code class="code">log(1.0 +. x)</code> (natural logarithm),
    giving numerically-accurate results even if <code class="code">x</code> is close to <code class="code">0.0</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALlong">long</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type (<code class="code">signed</code>) <code class="code">long</code>.
</div>
</td></tr>
<tr><td><a href="Cstubs.html#VALlwt_jobs">lwt_jobs</a> [<a href="Cstubs.html">Cstubs</a>]</td>
<td><div class="info">
Generate code which implements C function calls as Lwt jobs:
</div>
</td></tr>
<tr><td><a href="Cstubs.html#VALlwt_preemptive">lwt_preemptive</a> [<a href="Cstubs.html">Cstubs</a>]</td>
<td><div class="info">
Generate code which runs C function calls with the Lwt_preemptive module:
</div>
</td></tr>
<tr><td align="left"><br>M</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALmake">make</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">make t n</code> creates an <code class="code">n</code>-length array of type <code class="code">t</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALmake">make</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Allocate a fresh, uninitialised structure or union value.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALmake">make</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
<code class="code">make x y</code> creates the long double complex value <code class="code">x + y * i</code>
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALmap">map</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">map t f a</code> is analogous to <code class="code">Array.map f a</code>: it creates a new array with
      element type <code class="code">t</code> whose elements are obtained by applying <code class="code">f</code> to the
      elements of <code class="code">a</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALmapi">mapi</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">mapi</code> behaves like <code class="code">Array.mapi</code>, except that it also passes the
      index of each element as the first argument to <code class="code">f</code> and the element
      itself as the second argument.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALmax_float">max_float</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
The largest positive finite value
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALmin_float">min_float</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
The smallest positive, non-zero, non-denormalized value
</div>
</td></tr>
<tr><td><a href="PosixTypes.html#VALmode_t">mode_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="LDouble.html#VALmodf">modf</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
return <code class="code">(fractional,integer)</code> parts of number.
</div>
</td></tr>
<tr><td><a href="Libffi_abi.html#VALms_cdecl">ms_cdecl</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="ComplexL.html#VALmul">mul</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Multiplication
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALmul">mul</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Multiplication
</div>
</td></tr>
<tr><td align="left"><br>N</td></tr>
<tr><td><a href="Libffi_abi.html#VALn32">n32</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Libffi_abi.html#VALn32_soft_float">n32_soft_float</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Libffi_abi.html#VALn64">n64</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Libffi_abi.html#VALn64_soft_float">n64_soft_float</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="LDouble.html#VALnan">nan</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
A special floating-point value denoting the result of an
   undefined operation such as <code class="code">0.0 /. 0.0</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALnativeint">nativeint</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type (<code class="code">signed</code>) <code class="code">int</code>.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALneg">neg</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Unary negation
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALneg">neg</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Negation
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALneg_infinity">neg_infinity</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Negative infinity
</div>
</td></tr>
<tr><td><a href="PosixTypes.html#VALnlink_t">nlink_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="ComplexL.html#VALnorm">norm</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Norm: given <code class="code">x + i.y</code>, returns <code class="code">sqrt(x^2 + y^2)</code>.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALnorm2">norm2</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Norm squared: given <code class="code">x + i.y</code>, returns <code class="code">x^2 + y^2</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALnull">null</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
A null pointer.
</div>
</td></tr>
<tr><td align="left"><br>O</td></tr>
<tr><td><a href="Libffi_abi.html#VALo32">o32</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Libffi_abi.html#VALo32_soft_float">o32_soft_float</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALocaml_bytes">ocaml_bytes</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the directly mapped storage of an OCaml byte array.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALocaml_bytes_start">ocaml_bytes_start</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">ocaml_bytes_start s</code> allows to pass a pointer to the contents of an OCaml
    byte array directly to a C function.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALocaml_string">ocaml_string</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the directly mapped storage of an OCaml string.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALocaml_string_start">ocaml_string_start</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">ocaml_string_start s</code> allows to pass a pointer to the contents of an OCaml
    string directly to a C function.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALof_complex">of_complex</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
create a long double complex from a Complex.t
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALof_float">of_float</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Create a long double from a float
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALof_int">of_int</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Create a long double from an int
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALof_list">of_list</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">of_list t l</code> builds an array of type <code class="code">t</code> of the same length as <code class="code">l</code>, and
      writes the elements of <code class="code">l</code> to the corresponding elements of the array.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALof_string">of_string</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Create a long double from a string
</div>
</td></tr>
<tr><td><a href="PosixTypes.html#VALoff_t">off_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.html#VALoffsetof">offsetof</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">offsetof f</code> returns the offset, in bytes, of the field <code class="code">f</code> from the
    beginning of the associated struct type.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALone">one</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
<code class="code">1 + i0</code>
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALone">one</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
1.0
</div>
</td></tr>
<tr><td><a href="Libffi_abi.html#VALosf">osf</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td align="left"><br>P</td></tr>
<tr><td><a href="Libffi_abi.html#VALpa32">pa32</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="PosixTypes.html#VALpid_t">pid_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="ComplexL.html#VALpolar">polar</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
<code class="code">polar norm arg</code> returns the complex having norm <code class="code">norm</code> and argument <code class="code">arg</code>.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALpow">pow</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Power function.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALpow">pow</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Exponentiation
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALptr">ptr</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Construct a pointer type from an existing type (called the <i>reference
      type</i>).
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALptr_compare">ptr_compare</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
If <code class="code">p</code> and <code class="code">q</code> are pointers to elements <code class="code">i</code> and <code class="code">j</code> of the same array then
    <code class="code">ptr_compare p q</code> compares the indexes of the elements.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALptr_diff">ptr_diff</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">ptr_diff p q</code> computes <code class="code">q - p</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALptr_of_raw_address">ptr_of_raw_address</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Convert the numeric representation of an address to a pointer
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALptr_opt">ptr_opt</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Construct a pointer type from an existing type (called the <i>reference
      type</i>).
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALptrdiff_t">ptrdiff_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">ptrdiff_t</code>.
</div>
</td></tr>
<tr><td align="left"><br>R</td></tr>
<tr><td><a href="Ctypes.html#VALraw_address_of_ptr">raw_address_of_ptr</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">raw_address_of_ptr p</code> returns the numeric representation of p.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALre">re</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
return the real part of the long double complex
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALreference_type">reference_type</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Retrieve the reference type of a pointer.
</div>
</td></tr>
<tr><td><a href="Ctypes.Root.html#VALrelease">release</a> [<a href="Ctypes.Root.html">Ctypes.Root</a>]</td>
<td><div class="info">
<code class="code">release p</code> unregsiters the root <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALrem">rem</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
<code class="code">rem x y</code> is the remainder of dividing x by y
</div>
</td></tr>
<tr><td><a href="Cstubs.html#VALreturn_errno">return_errno</a> [<a href="Cstubs.html">Cstubs</a>]</td>
<td><div class="info">
Generate code that returns errno in addition to the return value of each function.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALreturning">returning</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Give the return type of a C function.
</div>
</td></tr>
<tr><td><a href="Ctypes.FOREIGN.html#VALreturning">returning</a> [<a href="Ctypes.FOREIGN.html">Ctypes.FOREIGN</a>]</td>
<td></td></tr>
<tr><td align="left"><br>S</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALschar">schar</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">signed char</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALseal">seal</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
<code class="code">seal t</code> completes the struct or union type <code class="code">t</code> so that no further fields
      can be added.
</div>
</td></tr>
<tr><td><a href="Cstubs.html#VALsequential">sequential</a> [<a href="Cstubs.html">Cstubs</a>]</td>
<td><div class="info">
Generate code with no special support for concurrency.
</div>
</td></tr>
<tr><td><a href="Ctypes.Root.html#VALset">set</a> [<a href="Ctypes.Root.html">Ctypes.Root</a>]</td>
<td><div class="info">
<code class="code">set p v</code> updates the OCaml value stored as a root at <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALset">set</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">set a n v</code> overwrites the <code class="code">n</code>th element of the zero-indexed array <code class="code">a</code>
      with <code class="code">v</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALsetf">setf</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">setf s f v</code> overwrites the value of the field <code class="code">f</code> in the structure or
    union <code class="code">s</code> with <code class="code">v</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALshort">short</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type (<code class="code">signed</code>) <code class="code">short</code>.
</div>
</td></tr>
<tr><td><a href="PosixTypes.html#VALsigset_t">sigset_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="LDouble.html#VALsin">sin</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Sine.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALsinh">sinh</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Hyperbolic sine
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALsint">sint</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">int</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALsize_t">size_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">size_t</code>, an alias for one of the unsigned
      integer types.
</div>
</td></tr>
<tr><td><a href="PosixTypes.html#VALsize_t">size_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.html#VALsizeof">sizeof</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">sizeof t</code> computes the size in bytes of the type <code class="code">t</code>.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALsqrt">sqrt</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Square root.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALsqrt">sqrt</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Square root
</div>
</td></tr>
<tr><td><a href="PosixTypes.html#VALssize_t">ssize_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes.CArray.html#VALstart">start</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
Return the address of the first element of the given array.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALstatic_funptr">static_funptr</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Construct a function pointer type from an existing function type
      (called the <i>reference type</i>).
</div>
</td></tr>
<tr><td><a href="Libffi_abi.html#VALstdcall">stdcall</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALstring">string</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
A high-level representation of the string type.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALstring_from_ptr">string_from_ptr</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
<code class="code">string_from_ptr p ~length</code> creates a string initialized with the <code class="code">length</code>
    characters at address <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALstring_of">string_of</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Return a string representation of the C value.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALstring_of_fn">string_of_fn</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Return a C representation of the function type.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALstring_of_typ">string_of_typ</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Return a C representation of the type.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALstring_opt">string_opt</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
A high-level representation of the string type.
</div>
</td></tr>
<tr><td><a href="Cstubs_inverted.INTERNAL.html#VALstructure">structure</a> [<a href="Cstubs_inverted.INTERNAL.html">Cstubs_inverted.INTERNAL</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALstructure">structure</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Construct a new structure type.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALsub">sub</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">sub a ~pos ~length</code> creates a fresh array of length <code class="code">length</code> containing
      the elements <code class="code">a.(pos)</code> to <code class="code">a.(pos + length - 1)</code> of <code class="code">a</code>.
</div>
</td></tr>
<tr><td><a href="ComplexL.html#VALsub">sub</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Subtraction
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALsub">sub</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Subtraction
</div>
</td></tr>
<tr><td><a href="Libffi_abi.html#VALsysv">sysv</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td align="left"><br>T</td></tr>
<tr><td><a href="LDouble.html#VALtan">tan</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Tangent.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALtanh">tanh</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Hyperbolic tangent
</div>
</td></tr>
<tr><td><a href="Libffi_abi.html#VALthiscall">thiscall</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="PosixTypes.html#VALtime_t">time_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="ComplexL.html#VALto_complex">to_complex</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
Convert a long double complex to a Complex.t.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALto_float">to_float</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Convert a long double to a float.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALto_int">to_int</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Convert a long double to an int.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALto_list">to_list</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">to_list a</code> builds a list of the same length as <code class="code">a</code> such that each
      element of the list is the result of reading the corresponding element of
      <code class="code">a</code>.
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALto_string">to_string</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
Convert a long double to a string.
</div>
</td></tr>
<tr><td><a href="Ctypes.html#VALto_voidp">to_voidp</a> [<a href="Ctypes.html">Ctypes</a>]</td>
<td><div class="info">
Conversion to <code class="code">void *</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALtyp_of_bigarray_kind">typ_of_bigarray_kind</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
<code class="code">typ_of_bigarray_kind k</code> is the type corresponding to the Bigarray kind
      <code class="code">k</code>.
</div>
</td></tr>
<tr><td><a href="Cstubs_inverted.INTERNAL.html#VALtypedef">typedef</a> [<a href="Cstubs_inverted.INTERNAL.html">Cstubs_inverted.INTERNAL</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALtypedef">typedef</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
<code class="code">typedef t name</code> creates a C type representation <code class="code">t'</code> which
      is equivalent to <code class="code">t</code> except its name is printed as <code class="code">name</code>.
</div>
</td></tr>
<tr><td align="left"><br>U</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALuchar">uchar</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">unsigned char</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALuint">uint</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">unsigned int</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALuint16_t">uint16_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing a 16-bit unsigned integer C type.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALuint32_t">uint32_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing a 32-bit unsigned integer C type.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALuint64_t">uint64_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing a 64-bit unsigned integer C type.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALuint8_t">uint8_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing an 8-bit unsigned integer C type.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALuintptr_t">uintptr_t</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">uintptr_t</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALullong">ullong</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">unsigned long long</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALulong">ulong</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">unsigned long</code>.
</div>
</td></tr>
<tr><td><a href="Cstubs_inverted.INTERNAL.html#VALunion">union</a> [<a href="Cstubs_inverted.INTERNAL.html">Cstubs_inverted.INTERNAL</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALunion">union</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Construct a new union type.
</div>
</td></tr>
<tr><td><a href="Libffi_abi.html#VALunix">unix</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Libffi_abi.html#VALunix64">unix64</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Cstubs.html#VALunlocked">unlocked</a> [<a href="Cstubs.html">Cstubs</a>]</td>
<td><div class="info">
Generate code that releases the runtime lock during C calls.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALunsafe_get">unsafe_get</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">unsafe_get a n</code> behaves like <code class="code">get a n</code> except that the check that <code class="code">n</code>
      between <code class="code">0</code> and <code class="code">(CArray.length a - 1)</code> is not performed.
</div>
</td></tr>
<tr><td><a href="Ctypes.CArray.html#VALunsafe_set">unsafe_set</a> [<a href="Ctypes.CArray.html">Ctypes.CArray</a>]</td>
<td><div class="info">
<code class="code">unsafe_set a n v</code> behaves like <code class="code">set a n v</code> except that the check that
      <code class="code">n</code> between <code class="code">0</code> and <code class="code">(CArray.length a - 1)</code> is not performed.
</div>
</td></tr>
<tr><td><a href="PosixTypes.html#VALuseconds_t">useconds_t</a> [<a href="PosixTypes.html">PosixTypes</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALushort">ushort</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C type <code class="code">unsigned short</code>.
</div>
</td></tr>
<tr><td align="left"><br>V</td></tr>
<tr><td><a href="Libffi_abi.html#VALv8">v8</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Libffi_abi.html#VALv8plus">v8plus</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Libffi_abi.html#VALv9">v9</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Libffi_abi.html#VALvfp">vfp</a> [<a href="Libffi_abi.html">Libffi_abi</a>]</td>
<td></td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALview">view</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
<code class="code">view ~read:r ~write:w t</code> creates a C type representation <code class="code">t'</code> which
      behaves like <code class="code">t</code> except that values read using <code class="code">t'</code> are subsequently
      transformed using the function <code class="code">r</code> and values written using <code class="code">t'</code> are first
      transformed using the function <code class="code">w</code>.
</div>
</td></tr>
<tr><td><a href="Ctypes_types.TYPE.html#VALvoid">void</a> [<a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a>]</td>
<td><div class="info">
Value representing the C void type.
</div>
</td></tr>
<tr><td align="left"><br>W</td></tr>
<tr><td><a href="Cstubs_inverted.html#VALwrite_c">write_c</a> [<a href="Cstubs_inverted.html">Cstubs_inverted</a>]</td>
<td><div class="info">
<code class="code">write_c fmt ~prefix bindings</code> generates C stubs for the functions bound
    with <code class="code">internal</code> in <code class="code">bindings</code>.
</div>
</td></tr>
<tr><td><a href="Cstubs.Types.html#VALwrite_c">write_c</a> [<a href="Cstubs.Types.html">Cstubs.Types</a>]</td>
<td></td></tr>
<tr><td><a href="Cstubs.html#VALwrite_c">write_c</a> [<a href="Cstubs.html">Cstubs</a>]</td>
<td><div class="info">
<code class="code">write_c fmt ~prefix bindings</code> generates C stubs for the functions bound
    with <code class="code">foreign</code> in <code class="code">bindings</code>.
</div>
</td></tr>
<tr><td><a href="Cstubs_structs.html#VALwrite_c">write_c</a> [<a href="Cstubs_structs.html">Cstubs_structs</a>]</td>
<td></td></tr>
<tr><td><a href="Cstubs_inverted.html#VALwrite_c_header">write_c_header</a> [<a href="Cstubs_inverted.html">Cstubs_inverted</a>]</td>
<td><div class="info">
<code class="code">write_c_header fmt ~prefix bindings</code> generates a C header file
    for the functions bound with <code class="code">internal</code> in <code class="code">bindings</code>.
</div>
</td></tr>
<tr><td><a href="Cstubs_inverted.html#VALwrite_ml">write_ml</a> [<a href="Cstubs_inverted.html">Cstubs_inverted</a>]</td>
<td><div class="info">
<code class="code">write_ml fmt ~prefix bindings</code> generates ML bindings for the functions
    bound with <code class="code">internal</code> in <code class="code">bindings</code>.
</div>
</td></tr>
<tr><td><a href="Cstubs.html#VALwrite_ml">write_ml</a> [<a href="Cstubs.html">Cstubs</a>]</td>
<td><div class="info">
<code class="code">write_ml fmt ~prefix bindings</code> generates ML bindings for the functions
    bound with <code class="code">foreign</code> in <code class="code">bindings</code>.
</div>
</td></tr>
<tr><td align="left"><br>Z</td></tr>
<tr><td><a href="ComplexL.html#VALzero">zero</a> [<a href="ComplexL.html">ComplexL</a>]</td>
<td><div class="info">
<code class="code">0 + i0</code>
</div>
</td></tr>
<tr><td><a href="LDouble.html#VALzero">zero</a> [<a href="LDouble.html">LDouble</a>]</td>
<td><div class="info">
0.0
</div>
</td></tr>
</table>
</body>
</html>