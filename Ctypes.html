<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Ctypes_structs.html">
<link rel="next" href="PosixTypes.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Ctypes_static" rel="Chapter" href="Ctypes_static.html">
<link title="Ctypes_primitive_types" rel="Chapter" href="Ctypes_primitive_types.html">
<link title="Unsigned" rel="Chapter" href="Unsigned.html">
<link title="Signed" rel="Chapter" href="Signed.html">
<link title="Ctypes_structs" rel="Chapter" href="Ctypes_structs.html">
<link title="Ctypes" rel="Chapter" href="Ctypes.html">
<link title="PosixTypes" rel="Chapter" href="PosixTypes.html">
<link title="Ctypes_types" rel="Chapter" href="Ctypes_types.html">
<link title="Ctypes_printers" rel="Chapter" href="Ctypes_printers.html">
<link title="Dl" rel="Chapter" href="Dl.html">
<link title="Libffi_abi" rel="Chapter" href="Libffi_abi.html">
<link title="Foreign" rel="Chapter" href="Foreign.html">
<link title="Cstubs_internals" rel="Chapter" href="Cstubs_internals.html">
<link title="Cstubs_structs" rel="Chapter" href="Cstubs_structs.html">
<link title="Cstubs" rel="Chapter" href="Cstubs.html">
<link title="Cstubs_inverted" rel="Chapter" href="Cstubs_inverted.html"><link title="Values representing C values" rel="Section" href="#values">
<link title="Exceptions" rel="Section" href="#2_Exceptions">
<link title="Struct and union types" rel="Subsection" href="#3_Structanduniontypes">
<link title="Operations on types" rel="Subsection" href="#3_Operationsontypes">
<link title="Pointer values" rel="Subsection" href="#3_Pointervalues">
<link title="Array values" rel="Subsection" href="#3_Arrayvalues">
<link title="Array values" rel="Subsection" href="#3_Arrayvalues">
<link title="Struct and union values" rel="Subsection" href="#3_Structandunionvalues">
<link title="Coercions" rel="Subsection" href="#3_Coercions">
<title>Ctypes</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Ctypes_structs.html" title="Ctypes_structs">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="PosixTypes.html" title="PosixTypes">Next</a>
</div>
<h1>Module <a href="type_Ctypes.html">Ctypes</a></h1>

<pre><span class="keyword">module</span> Ctypes: <code class="code">sig</code> <a href="Ctypes.html">..</a> <code class="code">end</code></pre><div class="info module top">
The core ctypes module.
<p>

    The main points of interest are the set of functions for describing C
    types (see <code class="code">types</code>) and the set of functions for accessing C values (see
    <a href="Ctypes.html#values"><i>Values representing C values</i></a>).  The <a href="Foreign.html#VALforeign"><code class="code">Foreign.foreign</code></a> function uses C type descriptions
    to bind external C values.<br>
</div>
<hr width="100%">
<br>
<h4 id="pointer_types">Pointer types</h4><br>

<pre><span id="TYPEpointer"><span class="keyword">type</span> <code class="type">('a, 'b)</code> pointer</span> = <code class="type">('a, 'b) <a href="Ctypes_static.html#TYPEpointer">Ctypes_static.pointer</a></code> </pre>
<div class="info ">
The type of pointer values. A value of type <code class="code">('a, [`C]) pointer</code> contains
    a C-compatible pointer, and a value of type <code class="code">('a, [`OCaml]) pointer</code>
    contains a pointer to a value that can be moved by OCaml runtime.<br>
</div>

<br>
<h4 id="4_Ccompatiblepointers">C-compatible pointers</h4><br>

<pre><span id="TYPEptr"><span class="keyword">type</span> <code class="type">'a</code> ptr</span> = <code class="type">('a, [ `C ]) <a href="Ctypes.html#TYPEpointer">pointer</a></code> </pre>
<div class="info ">
The type of C-compatible pointer values.  A value of type <code class="code">t ptr</code> can be
    used to read and write values of type <code class="code">t</code> at particular addresses.<br>
</div>


<pre><span id="TYPEocaml"><span class="keyword">type</span> <code class="type">'a</code> ocaml</span> = <code class="type">'a <a href="Ctypes_static.html#TYPEocaml">Ctypes_static.ocaml</a></code> </pre>
<div class="info ">
The type of pointer values pointing directly into OCaml values.
    <b>Pointers of this type should never be captured by external code</b>.
    In particular, functions accepting <code class="code">'a ocaml</code> pointers must not invoke
    any OCaml code.<br>
</div>

<br>
<h4 id="4_Carraytypes">C array types</h4><br>

<pre><span id="TYPEcarray"><span class="keyword">type</span> <code class="type">'a</code> carray</span> = <code class="type">'a <a href="Ctypes_static.html#TYPEcarray">Ctypes_static.carray</a></code> </pre>
<div class="info ">
The type of C array values.  A value of type <code class="code">t carray</code> can be used to read
    and write array objects in C-managed storage.<br>
</div>

<br>
<h4 id="4_Bigarraytypes">Bigarray types</h4><br>

<pre><span id="TYPEbigarray_class"><span class="keyword">type</span> <code class="type">'a</code> bigarray_class</span> = <code class="type">'a <a href="Ctypes_static.html#TYPEbigarray_class">Ctypes_static.bigarray_class</a></code> </pre>
<div class="info ">
The type of Bigarray classes.  There are four instances, one for each of
    the Bigarray submodules.<br>
</div>


<pre><span id="VALgenarray"><span class="keyword">val</span> genarray</span> : <code class="type">< ba_repr : 'b; bigarray : ('a, 'b, Bigarray.c_layout) Bigarray.Genarray.t;<br>         carray : 'a <a href="Ctypes.html#TYPEcarray">carray</a>; dims : int array; element : 'a ><br>       <a href="Ctypes.html#TYPEbigarray_class">bigarray_class</a></code></pre><div class="info ">
The class of <code class="code">Bigarray.Genarray.t</code> values<br>
</div>

<pre><span id="VALarray1"><span class="keyword">val</span> array1</span> : <code class="type">< ba_repr : 'b; bigarray : ('a, 'b, Bigarray.c_layout) Bigarray.Array1.t;<br>         carray : 'a <a href="Ctypes.html#TYPEcarray">carray</a>; dims : int; element : 'a ><br>       <a href="Ctypes.html#TYPEbigarray_class">bigarray_class</a></code></pre><div class="info ">
The class of <code class="code">Bigarray.Array1.t</code> values<br>
</div>

<pre><span id="VALarray2"><span class="keyword">val</span> array2</span> : <code class="type">< ba_repr : 'b; bigarray : ('a, 'b, Bigarray.c_layout) Bigarray.Array2.t;<br>         carray : 'a <a href="Ctypes.html#TYPEcarray">carray</a> <a href="Ctypes.html#TYPEcarray">carray</a>; dims : int * int; element : 'a ><br>       <a href="Ctypes.html#TYPEbigarray_class">bigarray_class</a></code></pre><div class="info ">
The class of <code class="code">Bigarray.Array2.t</code> values<br>
</div>

<pre><span id="VALarray3"><span class="keyword">val</span> array3</span> : <code class="type">< ba_repr : 'b; bigarray : ('a, 'b, Bigarray.c_layout) Bigarray.Array3.t;<br>         carray : 'a <a href="Ctypes.html#TYPEcarray">carray</a> <a href="Ctypes.html#TYPEcarray">carray</a> <a href="Ctypes.html#TYPEcarray">carray</a>;<br>         dims : int * int * int; element : 'a ><br>       <a href="Ctypes.html#TYPEbigarray_class">bigarray_class</a></code></pre><div class="info ">
The class of <code class="code">Bigarray.Array3.t</code> values<br>
</div>
<br>
<h3 id="3_Structanduniontypes">Struct and union types</h3><br>

<pre><span id="TYPEstructured"><span class="keyword">type</span> <code class="type">('a, 'kind)</code> structured</span> = <code class="type">('a, 'kind) <a href="Ctypes_static.html#TYPEstructured">Ctypes_static.structured</a></code> </pre>
<div class="info ">
The base type of values representing C struct and union types.  The
    <code class="code">'kind</code> parameter is a polymorphic variant type indicating whether the type
    represents a struct (<code class="code">`Struct</code>) or a union (<code class="code">`Union</code>).<br>
</div>


<pre><span id="TYPEstructure"><span class="keyword">type</span> <code class="type">'a</code> structure</span> = <code class="type">('a, [ `Struct ]) <a href="Ctypes.html#TYPEstructured">structured</a></code> </pre>
<div class="info ">
The type of values representing C struct types.<br>
</div>


<pre><span id="TYPEunion"><span class="keyword">type</span> <code class="type">'a</code> union</span> = <code class="type">('a, [ `Union ]) <a href="Ctypes.html#TYPEstructured">structured</a></code> </pre>
<div class="info ">
The type of values representing C union types.<br>
</div>


<pre><span id="TYPEfield"><span class="keyword">type</span> <code class="type">('a, 't)</code> field</span> = <code class="type">('a, 't) <a href="Ctypes_static.html#TYPEfield">Ctypes_static.field</a></code> </pre>
<div class="info ">
The type of values representing C struct or union members (called "fields"
    here).  A value of type <code class="code">(a, s) field</code> represents a field of type <code class="code">a</code> in a
    struct or union of type <code class="code">s</code>.<br>
</div>


<pre><span id="TYPEabstract"><span class="keyword">type</span> <code class="type">'a</code> abstract</span> = <code class="type">'a <a href="Ctypes_static.html#TYPEabstract">Ctypes_static.abstract</a></code> </pre>
<div class="info ">
The type of abstract values.  The purpose of the <code class="code">abstract</code> type is to
    represent values whose type varies from platform to platform.
<p>

    For example, the type <code class="code">pthread_t</code> is a pointer on some platforms, an
    integer on other platforms, and a struct on a third set of platforms.  One
    way to deal with this kind of situation is to have
    possibly-platform-specific code which interrogates the C type in some way
    to help determine an appropriate representation.  Another way is to use
    <code class="code">abstract</code>, leaving the representation opaque.
<p>

    (Note, however, that although <code class="code">pthread_t</code> is a convenient example, since
    the type used to implement it varies significantly across platforms, it's
    not actually a good match for <code class="code">abstract</code>, since values of type <code class="code">pthread_t</code>
    are passed and returned by value.)<br>
</div>


<pre><span class="keyword">include</span> <a href="Ctypes_types.TYPE.html">Ctypes_types.TYPE</a></pre>
<br>
<h3 id="3_Operationsontypes">Operations on types</h3><br>

<pre><span id="VAL( *:* )"><span class="keyword">val</span> ( *:* )</span> : <code class="type">('s, [ `Struct ]) <a href="Ctypes.html#TYPEstructured">structured</a> typ -><br>       'a typ -> ('a, ('s, [ `Struct ]) <a href="Ctypes.html#TYPEstructured">structured</a>) <a href="Ctypes.html#TYPEfield">field</a></code></pre><div class="info ">
<span class="warning">Deprecated.</span>Add an anonymous field to a structure.  Use <a href="Ctypes.html#TYPEfield"><code class="code">Ctypes.field</code></a> instead.<br>
</div>

<pre><span id="VAL(+:+)"><span class="keyword">val</span> (+:+)</span> : <code class="type">('s, [ `Union ]) <a href="Ctypes.html#TYPEstructured">structured</a> typ -><br>       'a typ -> ('a, ('s, [ `Union ]) <a href="Ctypes.html#TYPEstructured">structured</a>) <a href="Ctypes.html#TYPEfield">field</a></code></pre><div class="info ">
<span class="warning">Deprecated.</span>Add an anonymous field to a union.  Use <a href="Ctypes.html#TYPEfield"><code class="code">Ctypes.field</code></a> instead.<br>
</div>

<pre><span id="VALsizeof"><span class="keyword">val</span> sizeof</span> : <code class="type">'a typ -> int</code></pre><div class="info ">
<code class="code">sizeof t</code> computes the size in bytes of the type <code class="code">t</code>.  The exception
    <a href="Ctypes.html#EXCEPTIONIncompleteType"><code class="code">Ctypes.IncompleteType</code></a> is raised if <code class="code">t</code> is incomplete.<br>
</div>

<pre><span id="VALalignment"><span class="keyword">val</span> alignment</span> : <code class="type">'a typ -> int</code></pre><div class="info ">
<code class="code">alignment t</code> computes the alignment requirements of the type <code class="code">t</code>.  The
    exception <a href="Ctypes.html#EXCEPTIONIncompleteType"><code class="code">Ctypes.IncompleteType</code></a> is raised if <code class="code">t</code> is incomplete.<br>
</div>

<pre><span id="VALformat_typ"><span class="keyword">val</span> format_typ</span> : <code class="type">?name:string -> Format.formatter -> 'a typ -> unit</code></pre><div class="info ">
Pretty-print a C representation of the type to the specified formatter.<br>
</div>

<pre><span id="VALformat_fn"><span class="keyword">val</span> format_fn</span> : <code class="type">?name:string -> Format.formatter -> 'a fn -> unit</code></pre><div class="info ">
Pretty-print a C representation of the function type to the specified
    formatter.<br>
</div>

<pre><span id="VALstring_of_typ"><span class="keyword">val</span> string_of_typ</span> : <code class="type">?name:string -> 'a typ -> string</code></pre><div class="info ">
Return a C representation of the type.<br>
</div>

<pre><span id="VALstring_of_fn"><span class="keyword">val</span> string_of_fn</span> : <code class="type">?name:string -> 'a fn -> string</code></pre><div class="info ">
Return a C representation of the function type.<br>
</div>
<br>
<h2 id="values">Values representing C values</h2><br>

<pre><span id="VALformat"><span class="keyword">val</span> format</span> : <code class="type">'a typ -> Format.formatter -> 'a -> unit</code></pre><div class="info ">
Pretty-print a representation of the C value to the specified formatter.<br>
</div>

<pre><span id="VALstring_of"><span class="keyword">val</span> string_of</span> : <code class="type">'a typ -> 'a -> string</code></pre><div class="info ">
Return a string representation of the C value.<br>
</div>
<br>
<h3 id="3_Pointervalues">Pointer values</h3><br>

<pre><span id="VALnull"><span class="keyword">val</span> null</span> : <code class="type">unit <a href="Ctypes.html#TYPEptr">ptr</a></code></pre><div class="info ">
A null pointer.<br>
</div>

<pre><span id="VAL(!@)"><span class="keyword">val</span> (!@)</span> : <code class="type">'a <a href="Ctypes.html#TYPEptr">ptr</a> -> 'a</code></pre><div class="info ">
<code class="code">!@ p</code> dereferences the pointer <code class="code">p</code>.  If the reference type is a scalar
    type then dereferencing constructs a new value.  If the reference type is
    an aggregate type then dereferencing returns a value that references the
    memory pointed to by <code class="code">p</code>.<br>
</div>

<pre><span id="VAL(<-@)"><span class="keyword">val</span> (&lt;-@)</span> : <code class="type">'a <a href="Ctypes.html#TYPEptr">ptr</a> -> 'a -> unit</code></pre><div class="info ">
<code class="code">p &lt;-@ v</code> writes the value <code class="code">v</code> to the address <code class="code">p</code>.<br>
</div>

<pre><span id="VAL(+@)"><span class="keyword">val</span> (+@)</span> : <code class="type">('a, 'b) <a href="Ctypes.html#TYPEpointer">pointer</a> -> int -> ('a, 'b) <a href="Ctypes.html#TYPEpointer">pointer</a></code></pre><div class="info ">
If <code class="code">p</code> is a pointer to an array element then <code class="code">p +@ n</code> computes the
    address of the <code class="code">n</code>th next element.<br>
</div>

<pre><span id="VAL(-@)"><span class="keyword">val</span> (-@)</span> : <code class="type">('a, 'b) <a href="Ctypes.html#TYPEpointer">pointer</a> -> int -> ('a, 'b) <a href="Ctypes.html#TYPEpointer">pointer</a></code></pre><div class="info ">
If <code class="code">p</code> is a pointer to an array element then <code class="code">p -@ n</code> computes the address
    of the nth previous element.<br>
</div>

<pre><span id="VALptr_diff"><span class="keyword">val</span> ptr_diff</span> : <code class="type">('a, 'b) <a href="Ctypes.html#TYPEpointer">pointer</a> -> ('a, 'b) <a href="Ctypes.html#TYPEpointer">pointer</a> -> int</code></pre><div class="info ">
<code class="code">ptr_diff p q</code> computes <code class="code">q - p</code>.  As in C, both <code class="code">p</code> and <code class="code">q</code> must point
    into the same array, and the result value is the difference of the
    subscripts of the two array elements.<br>
</div>

<pre><span id="VALfrom_voidp"><span class="keyword">val</span> from_voidp</span> : <code class="type">'a typ -> unit <a href="Ctypes.html#TYPEptr">ptr</a> -> 'a <a href="Ctypes.html#TYPEptr">ptr</a></code></pre><div class="info ">
Conversion from <code class="code">void *</code>.<br>
</div>

<pre><span id="VALto_voidp"><span class="keyword">val</span> to_voidp</span> : <code class="type">'a <a href="Ctypes.html#TYPEptr">ptr</a> -> unit <a href="Ctypes.html#TYPEptr">ptr</a></code></pre><div class="info ">
Conversion to <code class="code">void *</code>.<br>
</div>

<pre><span id="VALallocate"><span class="keyword">val</span> allocate</span> : <code class="type">?finalise:('a <a href="Ctypes.html#TYPEptr">ptr</a> -> unit) -> 'a typ -> 'a -> 'a <a href="Ctypes.html#TYPEptr">ptr</a></code></pre><div class="info ">
<code class="code">allocate t v</code> allocates a fresh value of type <code class="code">t</code>, initialises it
    with <code class="code">v</code> and returns its address.  The argument <code class="code">?finalise</code>, if
    present, will be called just before the memory is freed.  The value
    will be automatically freed after no references to the pointer
    remain within the calling OCaml program.<br>
</div>

<pre><span id="VALallocate_n"><span class="keyword">val</span> allocate_n</span> : <code class="type">?finalise:('a <a href="Ctypes.html#TYPEptr">ptr</a> -> unit) -> 'a typ -> count:int -> 'a <a href="Ctypes.html#TYPEptr">ptr</a></code></pre><div class="info ">
<code class="code">allocate_n t ~count:n</code> allocates a fresh array with element type
    <code class="code">t</code> and length <code class="code">n</code>, and returns its address.  The argument
    <code class="code">?finalise</code>, if present, will be called just before the memory is
    freed.  The array will be automatically freed after no references
    to the pointer remain within the calling OCaml program.  The
    memory is allocated with libc's <code class="code">calloc</code> and is guaranteed to be
    zero-filled.<br>
</div>

<pre><span id="VALptr_compare"><span class="keyword">val</span> ptr_compare</span> : <code class="type">'a <a href="Ctypes.html#TYPEptr">ptr</a> -> 'a <a href="Ctypes.html#TYPEptr">ptr</a> -> int</code></pre><div class="info ">
If <code class="code">p</code> and <code class="code">q</code> are pointers to elements <code class="code">i</code> and <code class="code">j</code> of the same array then
    <code class="code">ptr_compare p q</code> compares the indexes of the elements.  The result is
    negative if <code class="code">i</code> is less than <code class="code">j</code>, positive if <code class="code">i</code> is greater than <code class="code">j</code>, and
    zero if <code class="code">i</code> and <code class="code">j</code> are equal.<br>
</div>

<pre><span id="VALreference_type"><span class="keyword">val</span> reference_type</span> : <code class="type">'a <a href="Ctypes.html#TYPEptr">ptr</a> -> 'a typ</code></pre><div class="info ">
Retrieve the reference type of a pointer.<br>
</div>

<pre><span id="VALptr_of_raw_address"><span class="keyword">val</span> ptr_of_raw_address</span> : <code class="type">nativeint -> unit <a href="Ctypes.html#TYPEptr">ptr</a></code></pre><div class="info ">
Convert the numeric representation of an address to a pointer<br>
</div>

<pre><span id="VALfunptr_of_raw_address"><span class="keyword">val</span> funptr_of_raw_address</span> : <code class="type">nativeint -> (unit -> unit) <a href="Ctypes_static.html#TYPEstatic_funptr">Ctypes_static.static_funptr</a></code></pre><div class="info ">
Convert the numeric representation of an address to a function pointer<br>
</div>

<pre><span id="VALraw_address_of_ptr"><span class="keyword">val</span> raw_address_of_ptr</span> : <code class="type">unit <a href="Ctypes.html#TYPEptr">ptr</a> -> nativeint</code></pre><div class="info ">
<code class="code">raw_address_of_ptr p</code> returns the numeric representation of p.
<p>

    Note that the return value remains valid only as long as the pointed-to
    object is alive.  If <code class="code">p</code> is a managed object (e.g. a value returned by
    <a href="Ctypes.html#VALmake"><code class="code">Ctypes.make</code></a>) then unless the caller retains a reference to <code class="code">p</code>, the object may
    be collected, invalidating the returned address.<br>
</div>

<pre><span id="VALstring_from_ptr"><span class="keyword">val</span> string_from_ptr</span> : <code class="type">char <a href="Ctypes.html#TYPEptr">ptr</a> -> length:int -> string</code></pre><div class="info ">
<code class="code">string_from_ptr p ~length</code> creates a string initialized with the <code class="code">length</code>
    characters at address <code class="code">p</code>.
<p>

    Raise <code class="code">Invalid_argument "Ctypes.string_from_ptr"</code> if <code class="code">length</code> is
    negative.<br>
</div>

<pre><span id="VALocaml_string_start"><span class="keyword">val</span> ocaml_string_start</span> : <code class="type">string -> string <a href="Ctypes.html#TYPEocaml">ocaml</a></code></pre><div class="info ">
<code class="code">ocaml_string_start s</code> allows to pass a pointer to the contents of an OCaml
    string directly to a C function.<br>
</div>

<pre><span id="VALocaml_bytes_start"><span class="keyword">val</span> ocaml_bytes_start</span> : <code class="type">Bytes.t -> Bytes.t <a href="Ctypes.html#TYPEocaml">ocaml</a></code></pre><div class="info ">
<code class="code">ocaml_bytes_start s</code> allows to pass a pointer to the contents of an OCaml
    byte array directly to a C function.<br>
</div>
<br>
<h3 id="3_Arrayvalues">Array values</h3><br>
<br>
<h3 id="3_Arrayvalues">Array values</h3><br>
<br>
<h4 id="4_Carrayvalues">C array values</h4><br>

<pre><span class="keyword">module</span> <a href="Ctypes.CArray.html">CArray</a>: <code class="code">sig</code> <a href="Ctypes.CArray.html">..</a> <code class="code">end</code></pre><div class="info">
Operations on C arrays.
</div>
<br>
<h4 id="4_Bigarrayvalues">Bigarray values</h4><br>

<pre><span id="VALbigarray_start"><span class="keyword">val</span> bigarray_start</span> : <code class="type">< ba_repr : 'c; bigarray : 'b; carray : 'd; dims : 'e; element : 'a ><br>       <a href="Ctypes.html#TYPEbigarray_class">bigarray_class</a> -> 'b -> 'a <a href="Ctypes.html#TYPEptr">ptr</a></code></pre><div class="info ">
Return the address of the first element of the given Bigarray value.<br>
</div>

<pre><span id="VALbigarray_of_ptr"><span class="keyword">val</span> bigarray_of_ptr</span> : <code class="type">< ba_repr : 'f; bigarray : 'b; carray : 'c; dims : 'i; element : 'a ><br>       <a href="Ctypes.html#TYPEbigarray_class">bigarray_class</a> -> 'i -> ('a, 'f) Bigarray.kind -> 'a <a href="Ctypes.html#TYPEptr">ptr</a> -> 'b</code></pre><div class="info ">
<code class="code">bigarray_of_ptr c dims k p</code> converts the C pointer <code class="code">p</code> to a bigarray
    value.  No copy is made; the bigarray references the memory pointed to by
    <code class="code">p</code>.<br>
</div>

<pre><span id="VALarray_of_bigarray"><span class="keyword">val</span> array_of_bigarray</span> : <code class="type">< ba_repr : 'a; bigarray : 'b; carray : 'c; dims : 'd; element : 'e ><br>       <a href="Ctypes.html#TYPEbigarray_class">bigarray_class</a> -> 'b -> 'c</code></pre><div class="info ">
<code class="code">array_of_bigarray c b</code> converts the bigarray value <code class="code">b</code> to a value of type
    <a href="Ctypes.CArray.html#TYPEt"><code class="code">Ctypes.CArray.t</code></a>.  No copy is made; the result occupies the same memory as
    <code class="code">b</code>.<br>
</div>
<br>
Convert a Bigarray value to a C array.<br>

<pre><span id="VALbigarray_of_array"><span class="keyword">val</span> bigarray_of_array</span> : <code class="type">< ba_repr : 'f; bigarray : 'b; carray : 'c <a href="Ctypes.html#TYPEcarray">carray</a>; dims : 'i;<br>         element : 'a ><br>       <a href="Ctypes.html#TYPEbigarray_class">bigarray_class</a> -> ('a, 'f) Bigarray.kind -> 'c <a href="Ctypes.html#TYPEcarray">carray</a> -> 'b</code></pre><div class="info ">
<code class="code">bigarray_of_array c k a</code> converts the <a href="Ctypes.CArray.html#TYPEt"><code class="code">Ctypes.CArray.t</code></a> value <code class="code">c</code> to a bigarray
    value.  No copy is made; the result occupies the same memory as <code class="code">c</code>.<br>
</div>
<br>
<h3 id="3_Structandunionvalues">Struct and union values</h3><br>

<pre><span id="VALmake"><span class="keyword">val</span> make</span> : <code class="type">?finalise:(('a, 'b) <a href="Ctypes.html#TYPEstructured">structured</a> -> unit) -><br>       ('a, 'b) <a href="Ctypes.html#TYPEstructured">structured</a> typ -> ('a, 'b) <a href="Ctypes.html#TYPEstructured">structured</a></code></pre><div class="info ">
Allocate a fresh, uninitialised structure or union value.  The argument
    <code class="code">?finalise</code>, if present, will be called just before the underlying memory is
    freed.<br>
</div>

<pre><span id="VALsetf"><span class="keyword">val</span> setf</span> : <code class="type">('b, 'c) <a href="Ctypes.html#TYPEstructured">structured</a> -><br>       ('a, ('b, 'c) <a href="Ctypes.html#TYPEstructured">structured</a>) <a href="Ctypes.html#TYPEfield">field</a> -> 'a -> unit</code></pre><div class="info ">
<code class="code">setf s f v</code> overwrites the value of the field <code class="code">f</code> in the structure or
    union <code class="code">s</code> with <code class="code">v</code>.<br>
</div>

<pre><span id="VALgetf"><span class="keyword">val</span> getf</span> : <code class="type">('b, 'c) <a href="Ctypes.html#TYPEstructured">structured</a> -><br>       ('a, ('b, 'c) <a href="Ctypes.html#TYPEstructured">structured</a>) <a href="Ctypes.html#TYPEfield">field</a> -> 'a</code></pre><div class="info ">
<code class="code">getf s f</code> retrieves the value of the field <code class="code">f</code> in the structure or union
    <code class="code">s</code>.  The semantics for non-scalar types are non-copying, as for
    <a href="Ctypes.html#VAL(!@)"><code class="code">Ctypes.(!@)</code></a>.<br>
</div>

<pre><span id="VAL(@.)"><span class="keyword">val</span> (@.)</span> : <code class="type">('b, 'c) <a href="Ctypes.html#TYPEstructured">structured</a> -><br>       ('a, ('b, 'c) <a href="Ctypes.html#TYPEstructured">structured</a>) <a href="Ctypes.html#TYPEfield">field</a> -> 'a <a href="Ctypes.html#TYPEptr">ptr</a></code></pre><div class="info ">
<code class="code">s @. f</code> computes the address of the field <code class="code">f</code> in the structure or union
    value <code class="code">s</code>.<br>
</div>

<pre><span id="VAL(|->)"><span class="keyword">val</span> (|-&gt;)</span> : <code class="type">('b, 'c) <a href="Ctypes.html#TYPEstructured">structured</a> <a href="Ctypes.html#TYPEptr">ptr</a> -><br>       ('a, ('b, 'c) <a href="Ctypes.html#TYPEstructured">structured</a>) <a href="Ctypes.html#TYPEfield">field</a> -> 'a <a href="Ctypes.html#TYPEptr">ptr</a></code></pre><div class="info ">
<code class="code">p |-&gt; f</code> computes the address of the field <code class="code">f</code> in the structure or union
    value pointed to by <code class="code">p</code>.<br>
</div>

<pre><span id="VALoffsetof"><span class="keyword">val</span> offsetof</span> : <code class="type">('a, 'b <a href="Ctypes.html#TYPEstructure">structure</a>) <a href="Ctypes.html#TYPEfield">field</a> -> int</code></pre><div class="info ">
<code class="code">offsetof f</code> returns the offset, in bytes, of the field <code class="code">f</code> from the
    beginning of the associated struct type.<br>
</div>

<pre><span id="VALfield_type"><span class="keyword">val</span> field_type</span> : <code class="type">('a, 'b) <a href="Ctypes.html#TYPEfield">field</a> -> 'a typ</code></pre><div class="info ">
<code class="code">field_type f</code> returns the type of the field <code class="code">f</code>.<br>
</div>

<pre><span id="VALfield_name"><span class="keyword">val</span> field_name</span> : <code class="type">('a, 'b) <a href="Ctypes.html#TYPEfield">field</a> -> string</code></pre><div class="info ">
<code class="code">field_name f</code> returns the name of the field <code class="code">f</code>.<br>
</div>

<pre><span id="VALaddr"><span class="keyword">val</span> addr</span> : <code class="type">('a, 'b) <a href="Ctypes.html#TYPEstructured">structured</a> -> ('a, 'b) <a href="Ctypes.html#TYPEstructured">structured</a> <a href="Ctypes.html#TYPEptr">ptr</a></code></pre><div class="info ">
<code class="code">addr s</code> returns the address of the structure or union <code class="code">s</code>.<br>
</div>
<br>
<h3 id="3_Coercions">Coercions</h3><br>

<pre><span id="VALcoerce"><span class="keyword">val</span> coerce</span> : <code class="type">'a typ -> 'b typ -> 'a -> 'b</code></pre><div class="info ">
<code class="code">coerce t1 t2</code> returns a coercion function between the types represented
    by <code class="code">t1</code> and <code class="code">t2</code>.  If <code class="code">t1</code> cannot be coerced to <code class="code">t2</code>, <code class="code">coerce</code> raises
    <a href="Ctypes.html#EXCEPTIONUncoercible"><code class="code">Ctypes.Uncoercible</code></a>.
<p>

    The following coercions are currently supported:
<p>
<ul>
<li>All function and object pointer types are intercoercible.</li>
<li>Any type may be coerced to <code class="code">void</code></li>
<li>There is a coercion between a <code class="code">view</code> and another type <code class="code">t</code> (in either
       direction) if there is a coercion between the representation type
       underlying the view and <code class="code">t</code>.</li>
<li>Coercion is transitive: if <code class="code">t1</code> is coercible to <code class="code">t2</code> and <code class="code">t2</code> is
       coercible to <code class="code">t3</code>, then <code class="code">t1</code> is directly coercible to <code class="code">t3</code>.</li>
</ul>

    The set of supported coercions is subject to change.  Future versions of
    ctypes may both add new types of coercion and restrict the existing
    coercions.<br>
</div>

<pre><span id="VALcoerce_fn"><span class="keyword">val</span> coerce_fn</span> : <code class="type">'a fn -> 'b fn -> 'a -> 'b</code></pre><div class="info ">
<code class="code">coerce_fn f1 f2</code> returns a coercion function between the function
    types represented by <code class="code">f1</code> and <code class="code">f2</code>.  If <code class="code">f1</code> cannot be coerced to
    <code class="code">f2</code>, <code class="code">coerce_fn</code> raises <a href="Ctypes.html#EXCEPTIONUncoercible"><code class="code">Ctypes.Uncoercible</code></a>.
<p>

    A function type <code class="code">f1</code> may be coerced to another function type <code class="code">f2</code>
    if all of the following hold:
<p>
<ul>
<li>the C types described by <code class="code">f1</code> and <code class="code">f2</code> have the same arity</li>
</ul>
<ul>
<li>each argument of <code class="code">f2</code> may be coerced to the corresponding
        argument of <code class="code">f1</code></li>
</ul>
<ul>
<li>the return type of <code class="code">f1</code> may be coerced to the return type of <code class="code">f2</code></li>
</ul>

    The set of supported coercions is subject to change.  Future versions of
    ctypes may both add new types of coercion and restrict the existing
    coercions.<br>
</div>

<pre><span class="keyword">module</span> <a href="Ctypes.Root.html">Root</a>: <code class="code">sig</code> <a href="Ctypes.Root.html">..</a> <code class="code">end</code></pre><div class="info">
Registration of OCaml values as roots
</div>
<br>
<h2 id="2_Exceptions">Exceptions</h2><br>

<pre><span id="EXCEPTIONUnsupported"><span class="keyword">exception</span> Unsupported</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info ">
An attempt was made to use a feature not currently supported by ctypes.
    In practice this refers to attempts to use an union, array or abstract
    type as an argument or return type of a function.<br>
</div>

<pre><span id="EXCEPTIONModifyingSealedType"><span class="keyword">exception</span> ModifyingSealedType</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info ">
An attempt was made to modify a sealed struct or union type
    description.<br>
</div>

<pre><span id="EXCEPTIONIncompleteType"><span class="keyword">exception</span> IncompleteType</span></pre>
<div class="info ">
An attempt was made to compute the size or alignment of an incomplete
    type.
<p>

    The incomplete types are struct and union types that have not been sealed,
    and the void type.
<p>

    It is not permitted to compute the size or alignment requirements of an
    incomplete type, to use it as a struct or union member, to read or write a
    value of the type through a pointer or to use it as the referenced type in
    pointer arithmetic.  Additionally, incomplete struct and union types
    cannot be used as argument or return types.<br>
</div>

<pre><span id="TYPEuncoercible_info"><span class="keyword">type</span> <code class="type"></code>uncoercible_info</span> </pre>


<pre><span id="EXCEPTIONUncoercible"><span class="keyword">exception</span> Uncoercible</span> <span class="keyword">of</span> <code class="type"><a href="Ctypes.html#TYPEuncoercible_info">uncoercible_info</a></code></pre>
<div class="info ">
An attempt was made to coerce between uncoercible types.<br>
</div>
</body></html>